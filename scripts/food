#!/usr/bin/env ruby

require 'pg'
require 'json'

DATABASE_NAME = 'food' # the postgresql database name you've created

Kernel.trap('PIPE') { exit }

# TODO: adapt SQL for prepared statements
# TODO: use leading minus to indicate "NOT ILIKE" instead of "ILKE"

def search_terms(*words)
  terms = []
  words.each { |word| terms.push "'%#{word.gsub(/[^a-z]/i, '').strip}%'" }
  return nil if terms.empty?
  return 'description ILIKE ' + terms.join(' AND description ILIKE ')
end

# not yet working
# def search_terms2(*words)
#   terms = words.map{ |w| '(?:' + w.sub(/[^a-z]/i, '') + ')'}.join
# end

def usage()
  STDERR.puts "Usage: #{File.basename $0} search-term [ search-term *]", "       note that search terms must be alphabetic"
  exit -1
end


# get_foods(db_connection) => [ record* ]
# where a record is a hash', e.g.:
#   "id": "16359",
#   "description": "Chickpeas (garbanzo beans, bengal gram), mature seeds, canned, drained, rinsed in tap water",
#   "kcal": 138,
#   "food_group": "Legumes and Legume Products",
#   "refuse_percentage": 0,
#   "refuse_description": null

def get_foods(connection)
  search_clause = search_terms(*ARGV)
  usage() unless search_clause
  list = []

  results = connection.exec("SELECT * FROM foods WHERE #{search_clause}")
  results.each do |result|
    rec = {
      id:                 result['id'],
      kcal:               result['kcal'].to_i,
      refuse_percentage:  result['refuse_percentage'].to_i,
      refuse_description: "#{result['refuse_description']}".strip,
      description:        result['description'],
      food_group:         result['food_group']
    }
    list.push rec
  end
  return list
rescue PG::Error => e
  STDERR.puts e
  exit -1
end

# add_measured()
# augment a food record with additional measurement information

def add_measures(connection, food_record)
  results = connection.exec_prepared('measure_select', [ food_record[:id] ])

  kcals_per_100_grams = food_record[:kcal].to_f
  list = [ { measure: '100 grams', kcals: kcals_per_100_grams.round,  grams: 100 } ]

  # example record: { "amount": "1", "description": "cup", "grams": "185" }
  results.each do |result|
    amount, description, grams = result.fetch_values('amount', 'description', 'grams')
    text = "#{amount} #{description}".strip
    total_kcals = kcals_per_100_grams * grams.to_f / 100
    list.push( { measure: text.strip, kcals: total_kcals.round, grams: grams.to_f.round })
  end
  food_record[:measures] = list
rescue PG::Error => e
  STDERR.puts e
  exit -1
end


def get_connection(database_name)
  connection = PG::Connection.open(:dbname => database_name)
  connection.prepare('measure_select', 'SELECT amount, description, grams FROM weight WHERE id = $1 ORDER BY sequence')
  ## not yet working: connection.prepare('regexp_food_select', 'SELECT * FROM foods WHERE description ~* $1')
  return connection
rescue PG::Error => e
  STDERR.puts e
  exit -1
end

def summary_report(list)
  group = ''

  list.each do |rec|
    if rec[:food_group] != group
      group = rec[:food_group]
      puts '', group, group.gsub(/./, '*')
    end

    puts '', rec[:description]

    rec[:measures].each do |measure|
      puts sprintf(" %5i kcals per %s", measure[:kcals], measure[:measure])
    end

    if rec[:refuse_percentage] > 0
      puts sprintf("Refuse %i%% - %s", rec[:refuse_percentage], rec[:refuse_description])
    end
  end
end

# main()

conn = get_connection(DATABASE_NAME)
foods = get_foods(conn)
foods.each do |record|
  add_measures(conn, record)
end

list = foods.sort_by { |a| [ a[:food_group].downcase, a[:description].downcase ]}

# For a text report:

summary_report(list)

# For a GET from a REST API:

# puts JSON.pretty_generate(list)
